#!/bin/bash

# Note that parts of this depend on minikube at this time.

#set -x

# exit on (errors,) errors in pipelines, and unset vars:
#set -e
set -o pipefail
set -o nounset

# error msg
# print msg to stderr and exit with error
error() {
  >&2 echo "$@"
  exit 1
}

context=minikube
if [[ $(kubectl config current-context) == gke_* ]] ; then
  context=GKE
fi

# busy_wait cmd
# quickly retry command til it works, up to some limit
# idea: succeed fast, fail slow
busy_wait() {
  if [[ $1 == limit=* ]]; then
   limit="${1#*=}"
   shift
  else
    limit=90
  fi

  until "$@"; do
    if [[ limit -le 0 ]]; then
      error "giving up: busy_wait $*"
    fi
    limit=$(( limit - 1 ))
    sleep 1
  done
}

TEST_SUCCESSES=0
TEST_FAILURES=0

# test runner
# command to test &&:
# T $? msg..
T() {
  res=$1
  shift
  msg="$*"
  if [[ 0 -eq res ]]; then
    echo "PASS: $msg"
    ((++TEST_SUCCESSES))
  else
    echo "FAIL: $msg"
    # make it conditional on a cli arg whether we bail or not
    ((++TEST_FAILURES))
    # error "test failed"
  fi
}

# Note that this function calls exit, so should be last command in (sub)shell
test_summary() {
    if [ $TEST_FAILURES -eq 0 ] ; then
        echo "All ${0##*/} tests pass.  PASS: $TEST_SUCCESSES  FAIL: 0"
    else
        echo "Some ${0##*/} tests failed!  PASS: $TEST_SUCCESSES  FAIL: $TEST_FAILURES"
    fi

    exit $TEST_FAILURES
}


# Get URL for NodePort assignment
# nodeport <name>
nodeport() {
  if [[ $context == "minikube" ]]; then
    minikube service --namespace=lightbend --url $1
  elif [[ $context == "GKE" ]]; then
    get_ing_ip $1-ing
  fi
}

# curl_query <baseURL> <URI> [<curl-opt>...]
curl_query() {
  FETCH_BASE=$1
  FETCH_URI=$2
  shift 2
  curl -fsG "$@" "$FETCH_BASE/$FETCH_URI"
}


# ES console access test
# test_es_console_responding <url> [<curl-opt>...]
test_es_console_responding() {
  CONSOLE_URL=$1
  shift
  results=$( curl_query $CONSOLE_URL "" "$@" | fgrep -q '<title>Enterprise Suite Reactive Console</title>' )
  T $? ES2 console accessible via $CONSOLE_URL "$@"
}

# Grafana access test
test_grafana_responding() {
  results=$( curl_query $1 "api/org" | jq '.id' )
  ! [[ $results -eq 0 ]]
  T $? grafana service accessible via $1
}

# Prometheus access test
test_prom_responding() {
  status=$( curl_query $1 "api/v1/status/config" | jq '.status' )
  [[ $status = '"success"' ]]
  T $? prometheus service accessible via $1
}

# ES monitor API access test
test_es_monitor_API_responding() {
  status=$( curl_query $1 "status" | jq '.status' )
  [[ $status = '"success"' ]]
  T $? es-monitor-api service accessible via $1
}

# Alertmanager access test
test_alertmanager_responding() {
  results=$( curl_query $1 "" | fgrep -q '<title>Alertmanager</title>' )
  T $? alertmanager accessible via $1
}

# Create services-name-ing ingress if not present
createIngress() {
  if ! kubectl get ing -n lightbend "$1-ing"  > /dev/null 2>&1 ; then
    sed -e "s/{{INGRESS_NAME}}/$1-ing/g;s/{{SERVICE_NAME}}/$1/g;s/{{SERVICE_PORT}}/$2/g" \
            < resources/gke-ingress-test.template.yaml | kubectl apply -n lightbend -f -
    echo "create $1-ing for service $1 at port $2"
    busy_wait limit=180 get_ing_ip "$1-ing"
  fi
}

# Get ingress IP
# Return http://[[public-ip]]
get_ing_ip() {
  kubectl get ing "$1" -n lightbend -o json | jq -e '.status.loadBalancer.ingress[0].ip' | tr -d '"'| awk '$1 != "null" {print "http://"$1}'
}

init_gke_ingress() {
  if [[ $context == "GKE" ]]; then
    set -x
    kubectl apply -f resources/gke-ingress.yaml
    ES_CONSOLE_IP=$(busy_wait limit=180 get_ing_ip expose-es-console-ing)
    busy_wait limit=180 test_es_console_responding $ES_CONSOLE_IP
    unset -x
  fi
}

if [[ $context == "GKE2" ]]; then
  ing_pids=()
  declare -a servicePorts=("expose-es-console:80" "expose-grafana:3000" "expose-alertmanager:9093" \
    "expose-prometheus:9090")
  ## now loop through the above array
  for service in "${servicePorts[@]}" ; do
    service_name=$(echo $service | awk -F ':' '{print $1}')
    service_port=$(echo $service | awk -F ':' '{print $2}')
    createIngress $service_name $service_port &
    ing_pids+=($!)
  done

  for pid in "${ing_pids[@]}"; do
    wait "$pid"
  done
  wait
fi



